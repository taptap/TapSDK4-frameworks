// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.1.2 effective-5.10 (swiftlang-6.1.2.1.2 clang-1700.0.13.5)
// swift-module-flags: -target arm64-apple-ios11.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -module-name TapTapKingfisher
// swift-module-flags-ignorable:  -interface-compiler-version 6.1.2
import AVKit
import Accelerate
import Combine
import CommonCrypto
import CoreGraphics
import CoreImage
import Foundation
import ImageIO
import MobileCoreServices
import Swift
import SwiftUI
import UIKit
import UIKit
import UIKit
import UIKit
import UIKit
import UIKit
import UIKit
import UIKit
import UIKit
import UIKit
import UIKit
import UIKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
public protocol CacheSerializer {
  func data(with image: TapTapKingfisher.KFCrossPlatformImage, original: Foundation.Data?) -> Foundation.Data?
  func image(with data: Foundation.Data, options: TapTapKingfisher.KingfisherParsedOptionsInfo) -> TapTapKingfisher.KFCrossPlatformImage?
}
public struct DefaultCacheSerializer : TapTapKingfisher.CacheSerializer {
  public static let `default`: TapTapKingfisher.DefaultCacheSerializer
  public var compressionQuality: CoreFoundation.CGFloat
  public var preferCacheOriginalData: Swift.Bool
  public init()
  public func data(with image: TapTapKingfisher.KFCrossPlatformImage, original: Foundation.Data?) -> Foundation.Data?
  public func image(with data: Foundation.Data, options: TapTapKingfisher.KingfisherParsedOptionsInfo) -> TapTapKingfisher.KFCrossPlatformImage?
}
public enum DiskStorage {
  @_hasMissingDesignatedInitializers public class Backend<T> where T : TapTapKingfisher.DataTransformable {
    public var config: TapTapKingfisher.DiskStorage.Config
    final public let directoryURL: Foundation.URL
    convenience public init(config: TapTapKingfisher.DiskStorage.Config) throws
    public func store(value: T, forKey key: Swift.String, expiration: TapTapKingfisher.StorageExpiration? = nil) throws
    public func value(forKey key: Swift.String, extendingExpiration: TapTapKingfisher.ExpirationExtending = .cacheTime) throws -> T?
    public func isCached(forKey key: Swift.String) -> Swift.Bool
    public func isCached(forKey key: Swift.String, referenceDate: Foundation.Date) -> Swift.Bool
    public func remove(forKey key: Swift.String) throws
    public func removeAll() throws
    public func cacheFileURL(forKey key: Swift.String) -> Foundation.URL
    public func removeExpiredValues() throws -> [Foundation.URL]
    public func totalSize() throws -> Swift.UInt
    @objc deinit
  }
}
extension TapTapKingfisher.DiskStorage {
  public struct Config {
    public var sizeLimit: Swift.UInt
    public var expiration: TapTapKingfisher.StorageExpiration
    public var pathExtension: Swift.String?
    public var usesHashedFileName: Swift.Bool
    public var autoExtAfterHashedFileName: Swift.Bool
    public init(name: Swift.String, sizeLimit: Swift.UInt, fileManager: Foundation.FileManager = .default, directory: Foundation.URL? = nil)
  }
}
public struct FormatIndicatedCacheSerializer : TapTapKingfisher.CacheSerializer {
  public static let png: TapTapKingfisher.FormatIndicatedCacheSerializer
  public static let jpeg: TapTapKingfisher.FormatIndicatedCacheSerializer
  public static func jpeg(compressionQuality: CoreFoundation.CGFloat) -> TapTapKingfisher.FormatIndicatedCacheSerializer
  public static let gif: TapTapKingfisher.FormatIndicatedCacheSerializer
  public func data(with image: TapTapKingfisher.KFCrossPlatformImage, original: Foundation.Data?) -> Foundation.Data?
  public func image(with data: Foundation.Data, options: TapTapKingfisher.KingfisherParsedOptionsInfo) -> TapTapKingfisher.KFCrossPlatformImage?
}
extension Foundation.NSNotification.Name {
  public static let KingfisherDidCleanDiskCache: Foundation.Notification.Name
}
public let KingfisherDiskCacheCleanedHashKey: Swift.String
public enum CacheType {
  case none
  case memory
  case disk
  public var cached: Swift.Bool {
    get
  }
  public static func == (a: TapTapKingfisher.CacheType, b: TapTapKingfisher.CacheType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct CacheStoreResult {
  public let memoryCacheResult: Swift.Result<(), Swift.Never>
  public let diskCacheResult: Swift.Result<(), TapTapKingfisher.KingfisherError>
}
extension UIKit.UIImage : TapTapKingfisher.CacheCostCalculable {
  public var cacheCost: Swift.Int {
    get
  }
}
extension Foundation.Data : TapTapKingfisher.DataTransformable {
  public func toData() throws -> Foundation.Data
  public static func fromData(_ data: Foundation.Data) throws -> Foundation.Data
  public static let empty: Foundation.Data
}
public enum ImageCacheResult {
  case disk(TapTapKingfisher.KFCrossPlatformImage)
  case memory(TapTapKingfisher.KFCrossPlatformImage)
  case none
  public var image: TapTapKingfisher.KFCrossPlatformImage? {
    get
  }
  public var cacheType: TapTapKingfisher.CacheType {
    get
  }
}
open class ImageCache {
  public static let `default`: TapTapKingfisher.ImageCache
  final public let memoryStorage: TapTapKingfisher.MemoryStorage.Backend<TapTapKingfisher.KFCrossPlatformImage>
  final public let diskStorage: TapTapKingfisher.DiskStorage.Backend<Foundation.Data>
  public typealias DiskCachePathClosure = (Foundation.URL, Swift.String) -> Foundation.URL
  public init(memoryStorage: TapTapKingfisher.MemoryStorage.Backend<TapTapKingfisher.KFCrossPlatformImage>, diskStorage: TapTapKingfisher.DiskStorage.Backend<Foundation.Data>)
  convenience public init(name: Swift.String)
  convenience public init(name: Swift.String, cacheDirectoryURL: Foundation.URL?, diskCachePathClosure: TapTapKingfisher.ImageCache.DiskCachePathClosure? = nil) throws
  @objc deinit
  open func store(_ image: TapTapKingfisher.KFCrossPlatformImage, original: Foundation.Data? = nil, forKey key: Swift.String, options: TapTapKingfisher.KingfisherParsedOptionsInfo, toDisk: Swift.Bool = true, completionHandler: ((TapTapKingfisher.CacheStoreResult) -> Swift.Void)? = nil)
  open func store(_ image: TapTapKingfisher.KFCrossPlatformImage, original: Foundation.Data? = nil, forKey key: Swift.String, processorIdentifier identifier: Swift.String = "", cacheSerializer serializer: any TapTapKingfisher.CacheSerializer = DefaultCacheSerializer.default, toDisk: Swift.Bool = true, callbackQueue: TapTapKingfisher.CallbackQueue = .untouch, completionHandler: ((TapTapKingfisher.CacheStoreResult) -> Swift.Void)? = nil)
  open func storeToDisk(_ data: Foundation.Data, forKey key: Swift.String, processorIdentifier identifier: Swift.String = "", expiration: TapTapKingfisher.StorageExpiration? = nil, callbackQueue: TapTapKingfisher.CallbackQueue = .untouch, completionHandler: ((TapTapKingfisher.CacheStoreResult) -> Swift.Void)? = nil)
  open func removeImage(forKey key: Swift.String, processorIdentifier identifier: Swift.String = "", fromMemory: Swift.Bool = true, fromDisk: Swift.Bool = true, callbackQueue: TapTapKingfisher.CallbackQueue = .untouch, completionHandler: (() -> Swift.Void)? = nil)
  open func retrieveImage(forKey key: Swift.String, options: TapTapKingfisher.KingfisherOptionsInfo? = nil, callbackQueue: TapTapKingfisher.CallbackQueue = .mainCurrentOrAsync, completionHandler: ((Swift.Result<TapTapKingfisher.ImageCacheResult, TapTapKingfisher.KingfisherError>) -> Swift.Void)?)
  open func retrieveImageInMemoryCache(forKey key: Swift.String, options: TapTapKingfisher.KingfisherOptionsInfo? = nil) -> TapTapKingfisher.KFCrossPlatformImage?
  open func retrieveImageInDiskCache(forKey key: Swift.String, options: TapTapKingfisher.KingfisherOptionsInfo? = nil, callbackQueue: TapTapKingfisher.CallbackQueue = .untouch, completionHandler: @escaping (Swift.Result<TapTapKingfisher.KFCrossPlatformImage?, TapTapKingfisher.KingfisherError>) -> Swift.Void)
  public func clearCache(completion handler: (() -> Swift.Void)? = nil)
  @objc public func clearMemoryCache()
  open func clearDiskCache(completion handler: (() -> Swift.Void)? = nil)
  open func cleanExpiredCache(completion handler: (() -> Swift.Void)? = nil)
  open func cleanExpiredMemoryCache()
  open func cleanExpiredDiskCache(completion handler: (() -> Swift.Void)? = nil)
  @objc public func backgroundCleanExpiredDiskCache()
  open func imageCachedType(forKey key: Swift.String, processorIdentifier identifier: Swift.String = DefaultImageProcessor.default.identifier) -> TapTapKingfisher.CacheType
  public func isCached(forKey key: Swift.String, processorIdentifier identifier: Swift.String = DefaultImageProcessor.default.identifier) -> Swift.Bool
  open func hash(forKey key: Swift.String, processorIdentifier identifier: Swift.String = DefaultImageProcessor.default.identifier) -> Swift.String
  open func calculateDiskStorageSize(completion handler: @escaping (Swift.Result<Swift.UInt, TapTapKingfisher.KingfisherError>) -> Swift.Void)
  open func cachePath(forKey key: Swift.String, processorIdentifier identifier: Swift.String = DefaultImageProcessor.default.identifier) -> Swift.String
}
extension UIKit.UIApplication : TapTapKingfisher.KingfisherCompatible {
}
extension TapTapKingfisher.KingfisherWrapper where Base : UIKit.UIApplication {
  public static var shared: UIKit.UIApplication? {
    get
  }
}
public enum MemoryStorage {
  public class Backend<T> where T : TapTapKingfisher.CacheCostCalculable {
    public var config: TapTapKingfisher.MemoryStorage.Config {
      get
      set
    }
    public init(config: TapTapKingfisher.MemoryStorage.Config)
    public func removeExpired()
    public func store(value: T, forKey key: Swift.String, expiration: TapTapKingfisher.StorageExpiration? = nil)
    public func value(forKey key: Swift.String, extendingExpiration: TapTapKingfisher.ExpirationExtending = .cacheTime) -> T?
    public func isCached(forKey key: Swift.String) -> Swift.Bool
    public func remove(forKey key: Swift.String)
    public func removeAll()
    @objc deinit
  }
}
extension TapTapKingfisher.MemoryStorage {
  public struct Config {
    public var totalCostLimit: Swift.Int
    public var countLimit: Swift.Int
    public var expiration: TapTapKingfisher.StorageExpiration
    public let cleanInterval: Foundation.TimeInterval
    public init(totalCostLimit: Swift.Int, cleanInterval: Foundation.TimeInterval = 120)
  }
}
public enum StorageExpiration {
  case never
  case seconds(Foundation.TimeInterval)
  case days(Swift.Int)
  case date(Foundation.Date)
  case expired
}
public enum ExpirationExtending {
  case none
  case cacheTime
  case expirationTime(_: TapTapKingfisher.StorageExpiration)
}
public protocol CacheCostCalculable {
  var cacheCost: Swift.Int { get }
}
public protocol DataTransformable {
  func toData() throws -> Foundation.Data
  static func fromData(_ data: Foundation.Data) throws -> Self
  static var empty: Self { get }
}
extension TapTapKingfisher.KingfisherWrapper where Base : UIKit.UIImageView {
  @discardableResult
  public func setImage(with source: TapTapKingfisher.Source?, placeholder: (any TapTapKingfisher.Placeholder)? = nil, options: TapTapKingfisher.KingfisherOptionsInfo? = nil, progressBlock: TapTapKingfisher.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<TapTapKingfisher.RetrieveImageResult, TapTapKingfisher.KingfisherError>) -> Swift.Void)? = nil) -> TapTapKingfisher.DownloadTask?
  @discardableResult
  public func setImage(with source: TapTapKingfisher.Source?, placeholder: (any TapTapKingfisher.Placeholder)? = nil, options: TapTapKingfisher.KingfisherOptionsInfo? = nil, completionHandler: ((Swift.Result<TapTapKingfisher.RetrieveImageResult, TapTapKingfisher.KingfisherError>) -> Swift.Void)? = nil) -> TapTapKingfisher.DownloadTask?
  @discardableResult
  public func setImage(with resource: (any TapTapKingfisher.Resource)?, placeholder: (any TapTapKingfisher.Placeholder)? = nil, options: TapTapKingfisher.KingfisherOptionsInfo? = nil, progressBlock: TapTapKingfisher.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<TapTapKingfisher.RetrieveImageResult, TapTapKingfisher.KingfisherError>) -> Swift.Void)? = nil) -> TapTapKingfisher.DownloadTask?
  @discardableResult
  public func setImage(with resource: (any TapTapKingfisher.Resource)?, placeholder: (any TapTapKingfisher.Placeholder)? = nil, options: TapTapKingfisher.KingfisherOptionsInfo? = nil, completionHandler: ((Swift.Result<TapTapKingfisher.RetrieveImageResult, TapTapKingfisher.KingfisherError>) -> Swift.Void)? = nil) -> TapTapKingfisher.DownloadTask?
  @discardableResult
  public func setImage(with provider: (any TapTapKingfisher.ImageDataProvider)?, placeholder: (any TapTapKingfisher.Placeholder)? = nil, options: TapTapKingfisher.KingfisherOptionsInfo? = nil, progressBlock: TapTapKingfisher.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<TapTapKingfisher.RetrieveImageResult, TapTapKingfisher.KingfisherError>) -> Swift.Void)? = nil) -> TapTapKingfisher.DownloadTask?
  @discardableResult
  public func setImage(with provider: (any TapTapKingfisher.ImageDataProvider)?, placeholder: (any TapTapKingfisher.Placeholder)? = nil, options: TapTapKingfisher.KingfisherOptionsInfo? = nil, completionHandler: ((Swift.Result<TapTapKingfisher.RetrieveImageResult, TapTapKingfisher.KingfisherError>) -> Swift.Void)? = nil) -> TapTapKingfisher.DownloadTask?
  public func cancelDownloadTask()
}
extension TapTapKingfisher.KingfisherWrapper where Base : UIKit.UIImageView {
  public var taskIdentifier: TapTapKingfisher.Source.Identifier.Value? {
    get
  }
  public var indicatorType: TapTapKingfisher.IndicatorType {
    get
    set
  }
  public var indicator: (any TapTapKingfisher.Indicator)? {
    get
  }
  public var placeholder: (any TapTapKingfisher.Placeholder)? {
    get
  }
}
extension Swift.String : TapTapKingfisher.KingfisherCompatibleValue {
}
extension TapTapKingfisher.KingfisherWrapper where Base : UIKit.NSTextAttachment {
  @discardableResult
  public func setImage(with source: TapTapKingfisher.Source?, attributedView: TapTapKingfisher.KFCrossPlatformView, placeholder: TapTapKingfisher.KFCrossPlatformImage? = nil, options: TapTapKingfisher.KingfisherOptionsInfo? = nil, progressBlock: TapTapKingfisher.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<TapTapKingfisher.RetrieveImageResult, TapTapKingfisher.KingfisherError>) -> Swift.Void)? = nil) -> TapTapKingfisher.DownloadTask?
  @discardableResult
  public func setImage(with resource: (any TapTapKingfisher.Resource)?, attributedView: TapTapKingfisher.KFCrossPlatformView, placeholder: TapTapKingfisher.KFCrossPlatformImage? = nil, options: TapTapKingfisher.KingfisherOptionsInfo? = nil, progressBlock: TapTapKingfisher.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<TapTapKingfisher.RetrieveImageResult, TapTapKingfisher.KingfisherError>) -> Swift.Void)? = nil) -> TapTapKingfisher.DownloadTask?
  public func cancelDownloadTask()
}
extension TapTapKingfisher.KingfisherWrapper where Base : UIKit.NSTextAttachment {
  public var taskIdentifier: TapTapKingfisher.Source.Identifier.Value? {
    get
  }
}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@_Concurrency.MainActor @preconcurrency public struct KFImage : SwiftUICore.View {
  @available(*, deprecated, message: "Some options are not available in SwiftUI yet. Use `KFImage(source:isLoaded:)` to create a `KFImage` and configure the options through modifier instead.")
  @_Concurrency.MainActor @preconcurrency public init(source: TapTapKingfisher.Source?, options: TapTapKingfisher.KingfisherOptionsInfo? = nil, isLoaded: SwiftUICore.Binding<Swift.Bool> = .constant(false))
  @_Concurrency.MainActor @preconcurrency public init(source: TapTapKingfisher.Source?, isLoaded: SwiftUICore.Binding<Swift.Bool> = .constant(false))
  @_Concurrency.MainActor @preconcurrency public init(_ url: Foundation.URL?, isLoaded: SwiftUICore.Binding<Swift.Bool> = .constant(false))
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  @_Concurrency.MainActor @preconcurrency public func loadImmediately(_ start: Swift.Bool = true) -> TapTapKingfisher.KFImage
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  public typealias Body = @_opaqueReturnTypeOf("$s03TapA10Kingfisher7KFImageV4bodyQrvp", 0) __
}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension TapTapKingfisher.KFImage {
  @_Concurrency.MainActor @preconcurrency public func configure(_ block: @escaping (SwiftUICore.Image) -> SwiftUICore.Image) -> TapTapKingfisher.KFImage
  @_Concurrency.MainActor @preconcurrency public func resizable(capInsets: SwiftUICore.EdgeInsets = EdgeInsets(), resizingMode: SwiftUICore.Image.ResizingMode = .stretch) -> TapTapKingfisher.KFImage
  @_Concurrency.MainActor @preconcurrency public func renderingMode(_ renderingMode: SwiftUICore.Image.TemplateRenderingMode?) -> TapTapKingfisher.KFImage
  @_Concurrency.MainActor @preconcurrency public func interpolation(_ interpolation: SwiftUICore.Image.Interpolation) -> TapTapKingfisher.KFImage
  @_Concurrency.MainActor @preconcurrency public func antialiased(_ isAntialiased: Swift.Bool) -> TapTapKingfisher.KFImage
}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension TapTapKingfisher.KFImage {
  @_Concurrency.MainActor @preconcurrency public static func source(_ source: TapTapKingfisher.Source?, isLoaded: SwiftUICore.Binding<Swift.Bool> = .constant(false)) -> TapTapKingfisher.KFImage
  @_Concurrency.MainActor @preconcurrency public static func resource(_ resource: (any TapTapKingfisher.Resource)?, isLoaded: SwiftUICore.Binding<Swift.Bool> = .constant(false)) -> TapTapKingfisher.KFImage
  @_Concurrency.MainActor @preconcurrency public static func url(_ url: Foundation.URL?, cacheKey: Swift.String? = nil, isLoaded: SwiftUICore.Binding<Swift.Bool> = .constant(false)) -> TapTapKingfisher.KFImage
  @_Concurrency.MainActor @preconcurrency public static func dataProvider(_ provider: (any TapTapKingfisher.ImageDataProvider)?, isLoaded: SwiftUICore.Binding<Swift.Bool> = .constant(false)) -> TapTapKingfisher.KFImage
  @_Concurrency.MainActor @preconcurrency public static func data(_ data: Foundation.Data?, cacheKey: Swift.String, isLoaded: SwiftUICore.Binding<Swift.Bool> = .constant(false)) -> TapTapKingfisher.KFImage
}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension TapTapKingfisher.KFImage {
  @_Concurrency.MainActor @preconcurrency public func placeholder<Content>(@SwiftUICore.ViewBuilder _ content: () -> Content) -> TapTapKingfisher.KFImage where Content : SwiftUICore.View
  @_Concurrency.MainActor @preconcurrency public func cancelOnDisappear(_ flag: Swift.Bool) -> TapTapKingfisher.KFImage
  @_Concurrency.MainActor @preconcurrency public func fade(duration: Foundation.TimeInterval) -> TapTapKingfisher.KFImage
}
extension TapTapKingfisher.KingfisherWrapper where Base : UIKit.UIButton {
  @discardableResult
  public func setImage(with source: TapTapKingfisher.Source?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: TapTapKingfisher.KingfisherOptionsInfo? = nil, progressBlock: TapTapKingfisher.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<TapTapKingfisher.RetrieveImageResult, TapTapKingfisher.KingfisherError>) -> Swift.Void)? = nil) -> TapTapKingfisher.DownloadTask?
  @discardableResult
  public func setImage(with resource: (any TapTapKingfisher.Resource)?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: TapTapKingfisher.KingfisherOptionsInfo? = nil, progressBlock: TapTapKingfisher.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<TapTapKingfisher.RetrieveImageResult, TapTapKingfisher.KingfisherError>) -> Swift.Void)? = nil) -> TapTapKingfisher.DownloadTask?
  @discardableResult
  public func setImage(with source: TapTapKingfisher.Source?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, parsedOptions: TapTapKingfisher.KingfisherParsedOptionsInfo, progressBlock: TapTapKingfisher.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<TapTapKingfisher.RetrieveImageResult, TapTapKingfisher.KingfisherError>) -> Swift.Void)? = nil) -> TapTapKingfisher.DownloadTask?
  public func cancelImageDownloadTask()
  @discardableResult
  public func setBackgroundImage(with source: TapTapKingfisher.Source?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: TapTapKingfisher.KingfisherOptionsInfo? = nil, progressBlock: TapTapKingfisher.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<TapTapKingfisher.RetrieveImageResult, TapTapKingfisher.KingfisherError>) -> Swift.Void)? = nil) -> TapTapKingfisher.DownloadTask?
  @discardableResult
  public func setBackgroundImage(with resource: (any TapTapKingfisher.Resource)?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: TapTapKingfisher.KingfisherOptionsInfo? = nil, progressBlock: TapTapKingfisher.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<TapTapKingfisher.RetrieveImageResult, TapTapKingfisher.KingfisherError>) -> Swift.Void)? = nil) -> TapTapKingfisher.DownloadTask?
  public func cancelBackgroundImageDownloadTask()
}
extension TapTapKingfisher.KingfisherWrapper where Base : UIKit.UIButton {
  public func taskIdentifier(for state: UIKit.UIControl.State) -> TapTapKingfisher.Source.Identifier.Value?
}
extension TapTapKingfisher.KingfisherWrapper where Base : UIKit.UIButton {
  public func backgroundTaskIdentifier(for state: UIKit.UIControl.State) -> TapTapKingfisher.Source.Identifier.Value?
}
public struct AVAssetImageDataProvider : TapTapKingfisher.ImageDataProvider {
  public enum AVAssetImageDataProviderError : Swift.Error {
    case userCancelled
    case invalidImage(_: CoreGraphics.CGImage?)
  }
  public let assetImageGenerator: AVFoundation.AVAssetImageGenerator
  public let time: CoreMedia.CMTime
  public var cacheKey: Swift.String {
    get
  }
  public init(assetImageGenerator: AVFoundation.AVAssetImageGenerator, time: CoreMedia.CMTime)
  public init(assetURL: Foundation.URL, time: CoreMedia.CMTime)
  public init(assetURL: Foundation.URL, seconds: Foundation.TimeInterval)
  public func data(handler: @escaping (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
}
public protocol ImageDataProvider {
  var cacheKey: Swift.String { get }
  func data(handler: @escaping (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
  var contentURL: Foundation.URL? { get }
}
extension TapTapKingfisher.ImageDataProvider {
  public var contentURL: Foundation.URL? {
    get
  }
  public func convertToSource() -> TapTapKingfisher.Source
}
public struct LocalFileImageDataProvider : TapTapKingfisher.ImageDataProvider {
  public let fileURL: Foundation.URL
  public init(fileURL: Foundation.URL, cacheKey: Swift.String? = nil)
  public var cacheKey: Swift.String
  public func data(handler: (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
  public var contentURL: Foundation.URL? {
    get
  }
}
public struct Base64ImageDataProvider : TapTapKingfisher.ImageDataProvider {
  public let base64String: Swift.String
  public init(base64String: Swift.String, cacheKey: Swift.String)
  public var cacheKey: Swift.String
  public func data(handler: (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
}
public struct RawImageDataProvider : TapTapKingfisher.ImageDataProvider {
  public let data: Foundation.Data
  public init(data: Foundation.Data, cacheKey: Swift.String)
  public var cacheKey: Swift.String
  public func data(handler: @escaping (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
}
public protocol Resource {
  var cacheKey: Swift.String { get }
  var downloadURL: Foundation.URL { get }
}
extension TapTapKingfisher.Resource {
  public func convertToSource(overrideCacheKey: Swift.String? = nil) -> TapTapKingfisher.Source
}
public struct ImageResource : TapTapKingfisher.Resource {
  public init(downloadURL: Foundation.URL, cacheKey: Swift.String? = nil)
  public let cacheKey: Swift.String
  public let downloadURL: Foundation.URL
}
extension Foundation.URL : TapTapKingfisher.Resource {
  public var cacheKey: Swift.String {
    get
  }
  public var downloadURL: Foundation.URL {
    get
  }
}
public enum Source {
  public enum Identifier {
    public typealias Value = Swift.UInt
  }
  case network(any TapTapKingfisher.Resource)
  case provider(any TapTapKingfisher.ImageDataProvider)
  public var cacheKey: Swift.String {
    get
  }
  public var url: Foundation.URL? {
    get
  }
}
extension TapTapKingfisher.Source : Swift.Hashable {
  public static func == (lhs: TapTapKingfisher.Source, rhs: TapTapKingfisher.Source) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum KF {
  public static func source(_ source: TapTapKingfisher.Source?) -> TapTapKingfisher.KF.Builder
  public static func resource(_ resource: (any TapTapKingfisher.Resource)?) -> TapTapKingfisher.KF.Builder
  public static func url(_ url: Foundation.URL?, cacheKey: Swift.String? = nil) -> TapTapKingfisher.KF.Builder
  public static func dataProvider(_ provider: (any TapTapKingfisher.ImageDataProvider)?) -> TapTapKingfisher.KF.Builder
  public static func data(_ data: Foundation.Data?, cacheKey: Swift.String) -> TapTapKingfisher.KF.Builder
}
extension TapTapKingfisher.KF {
  @_hasMissingDesignatedInitializers public class Builder {
    public var options: TapTapKingfisher.KingfisherParsedOptionsInfo
    final public let onFailureDelegate: TapTapKingfisher.Delegate<TapTapKingfisher.KingfisherError, Swift.Void>
    final public let onSuccessDelegate: TapTapKingfisher.Delegate<TapTapKingfisher.RetrieveImageResult, Swift.Void>
    final public let onProgressDelegate: TapTapKingfisher.Delegate<(Swift.Int64, Swift.Int64), Swift.Void>
    @objc deinit
  }
}
extension TapTapKingfisher.KF.Builder {
  @discardableResult
  public func set(to imageView: TapTapKingfisher.KFCrossPlatformImageView) -> TapTapKingfisher.DownloadTask?
  @discardableResult
  public func set(to attachment: UIKit.NSTextAttachment, attributedView: TapTapKingfisher.KFCrossPlatformView) -> TapTapKingfisher.DownloadTask?
  @discardableResult
  public func set(to button: UIKit.UIButton, for state: UIKit.UIControl.State) -> TapTapKingfisher.DownloadTask?
  @discardableResult
  public func setBackground(to button: UIKit.UIButton, for state: UIKit.UIControl.State) -> TapTapKingfisher.DownloadTask?
}
extension TapTapKingfisher.KF.Builder {
  public func placeholder(_ placeholder: (any TapTapKingfisher.Placeholder)?) -> Self
  public func placeholder(_ image: TapTapKingfisher.KFCrossPlatformImage?) -> Self
}
extension TapTapKingfisher.KF.Builder {
  public func transition(_ transition: TapTapKingfisher.ImageTransition) -> Self
  public func fade(duration: Foundation.TimeInterval) -> Self
  public func keepCurrentImageWhileLoading(_ enabled: Swift.Bool = true) -> Self
  public func onlyLoadFirstFrame(_ enabled: Swift.Bool = true) -> Self
  public func onFailureImage(_ image: TapTapKingfisher.KFCrossPlatformImage?) -> Self
  public func progressiveJPEG(_ progressive: TapTapKingfisher.ImageProgressive? = .default) -> Self
}
extension TapTapKingfisher.KF {
  public struct RedirectPayload {
    public let task: TapTapKingfisher.SessionDataTask
    public let response: Foundation.HTTPURLResponse
    public let newRequest: Foundation.URLRequest
    public let completionHandler: (Foundation.URLRequest?) -> Swift.Void
  }
}
public protocol KFOptionSetter {
  var options: TapTapKingfisher.KingfisherParsedOptionsInfo { get nonmutating set }
  var onFailureDelegate: TapTapKingfisher.Delegate<TapTapKingfisher.KingfisherError, Swift.Void> { get }
  var onSuccessDelegate: TapTapKingfisher.Delegate<TapTapKingfisher.RetrieveImageResult, Swift.Void> { get }
  var onProgressDelegate: TapTapKingfisher.Delegate<(Swift.Int64, Swift.Int64), Swift.Void> { get }
  var delegateObserver: Swift.AnyObject { get }
}
extension TapTapKingfisher.KF.Builder : TapTapKingfisher.KFOptionSetter {
  public var delegateObserver: Swift.AnyObject {
    get
  }
}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension TapTapKingfisher.KFImage : TapTapKingfisher.KFOptionSetter {
  @_Concurrency.MainActor @preconcurrency public var options: TapTapKingfisher.KingfisherParsedOptionsInfo {
    get
    nonmutating set
  }
  @_Concurrency.MainActor @preconcurrency public var onFailureDelegate: TapTapKingfisher.Delegate<TapTapKingfisher.KingfisherError, Swift.Void> {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var onSuccessDelegate: TapTapKingfisher.Delegate<TapTapKingfisher.RetrieveImageResult, Swift.Void> {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var onProgressDelegate: TapTapKingfisher.Delegate<(Swift.Int64, Swift.Int64), Swift.Void> {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var delegateObserver: Swift.AnyObject {
    get
  }
}
extension TapTapKingfisher.KFOptionSetter {
  public func onProgress(_ block: TapTapKingfisher.DownloadProgressBlock?) -> Self
  public func onSuccess(_ block: ((TapTapKingfisher.RetrieveImageResult) -> Swift.Void)?) -> Self
  public func onFailure(_ block: ((TapTapKingfisher.KingfisherError) -> Swift.Void)?) -> Self
}
extension TapTapKingfisher.KFOptionSetter {
  public func targetCache(_ cache: TapTapKingfisher.ImageCache) -> Self
  public func originalCache(_ cache: TapTapKingfisher.ImageCache) -> Self
  public func downloader(_ downloader: TapTapKingfisher.ImageDownloader) -> Self
  public func downloadPriority(_ priority: Swift.Float) -> Self
  public func forceRefresh(_ enabled: Swift.Bool = true) -> Self
  public func fromMemoryCacheOrRefresh(_ enabled: Swift.Bool = true) -> Self
  public func cacheMemoryOnly(_ enabled: Swift.Bool = true) -> Self
  public func waitForCache(_ enabled: Swift.Bool = true) -> Self
  public func onlyFromCache(_ enabled: Swift.Bool = true) -> Self
  public func backgroundDecode(_ enabled: Swift.Bool = true) -> Self
  public func callbackQueue(_ queue: TapTapKingfisher.CallbackQueue) -> Self
  public func scaleFactor(_ factor: CoreFoundation.CGFloat) -> Self
  public func cacheOriginalImage(_ enabled: Swift.Bool = true) -> Self
  public func loadDiskFileSynchronously(_ enabled: Swift.Bool = true) -> Self
  public func processingQueue(_ queue: TapTapKingfisher.CallbackQueue?) -> Self
  public func alternativeSources(_ sources: [TapTapKingfisher.Source]?) -> Self
  public func retry(_ strategy: any TapTapKingfisher.RetryStrategy) -> Self
  public func retry(maxCount: Swift.Int, interval: TapTapKingfisher.DelayRetryStrategy.Interval = .seconds(3)) -> Self
  public func lowDataModeSource(_ source: TapTapKingfisher.Source?) -> Self
  public func forceTransition(_ enabled: Swift.Bool = true) -> Self
}
extension TapTapKingfisher.KFOptionSetter {
  public func requestModifier(_ modifier: any TapTapKingfisher.ImageDownloadRequestModifier) -> Self
  public func requestModifier(_ modifyBlock: @escaping (inout Foundation.URLRequest) -> Swift.Void) -> Self
}
extension TapTapKingfisher.KFOptionSetter {
  public func redirectHandler(_ handler: any TapTapKingfisher.ImageDownloadRedirectHandler) -> Self
  public func redirectHandler(_ block: @escaping (TapTapKingfisher.KF.RedirectPayload) -> Swift.Void) -> Self
}
extension TapTapKingfisher.KFOptionSetter {
  public func setProcessor(_ processor: any TapTapKingfisher.ImageProcessor) -> Self
  public func setProcessors(_ processors: [any TapTapKingfisher.ImageProcessor]) -> Self
  public func appendProcessor(_ processor: any TapTapKingfisher.ImageProcessor) -> Self
  public func roundCorner(radius: TapTapKingfisher.RoundCornerImageProcessor.Radius, targetSize: CoreFoundation.CGSize? = nil, roundingCorners corners: TapTapKingfisher.RectCorner = .all, backgroundColor: TapTapKingfisher.KFCrossPlatformColor? = nil) -> Self
  public func blur(radius: CoreFoundation.CGFloat) -> Self
  public func overlay(color: TapTapKingfisher.KFCrossPlatformColor, fraction: CoreFoundation.CGFloat = 0.5) -> Self
  public func tint(color: TapTapKingfisher.KFCrossPlatformColor) -> Self
  public func blackWhite() -> Self
  public func cropping(size: CoreFoundation.CGSize, anchor: CoreFoundation.CGPoint = .init(x: 0.5, y: 0.5)) -> Self
  public func downsampling(size: CoreFoundation.CGSize) -> Self
  public func resizing(referenceSize: CoreFoundation.CGSize, mode: TapTapKingfisher.ContentMode = .none) -> Self
}
extension TapTapKingfisher.KFOptionSetter {
  public func serialize(by cacheSerializer: any TapTapKingfisher.CacheSerializer) -> Self
  public func serialize(as format: TapTapKingfisher.ImageFormat, jpegCompressionQuality: CoreFoundation.CGFloat? = nil) -> Self
}
extension TapTapKingfisher.KFOptionSetter {
  public func imageModifier(_ modifier: (any TapTapKingfisher.ImageModifier)?) -> Self
  public func imageModifier(_ block: @escaping (inout TapTapKingfisher.KFCrossPlatformImage) throws -> Swift.Void) -> Self
}
extension TapTapKingfisher.KFOptionSetter {
  public func memoryCacheExpiration(_ expiration: TapTapKingfisher.StorageExpiration?) -> Self
  public func memoryCacheAccessExtending(_ extending: TapTapKingfisher.ExpirationExtending) -> Self
  public func diskCacheExpiration(_ expiration: TapTapKingfisher.StorageExpiration?) -> Self
  public func diskCacheAccessExtending(_ extending: TapTapKingfisher.ExpirationExtending) -> Self
}
public typealias KFCrossPlatformImage = UIKit.UIImage
public typealias KFCrossPlatformColor = UIKit.UIColor
public typealias KFCrossPlatformImageView = UIKit.UIImageView
public typealias KFCrossPlatformView = UIKit.UIView
public typealias KFCrossPlatformButton = UIKit.UIButton
public struct KingfisherWrapper<Base> {
  public let base: Base
  public init(_ base: Base)
}
public protocol KingfisherCompatible : AnyObject {
}
public protocol KingfisherCompatibleValue {
}
extension TapTapKingfisher.KingfisherCompatible {
  public var kf: TapTapKingfisher.KingfisherWrapper<Self> {
    get
    set
  }
}
extension TapTapKingfisher.KingfisherCompatibleValue {
  public var kf: TapTapKingfisher.KingfisherWrapper<Self> {
    get
    set
  }
}
extension UIKit.UIImage : TapTapKingfisher.KingfisherCompatible {
}
extension UIKit.UIImageView : TapTapKingfisher.KingfisherCompatible {
}
extension UIKit.UIButton : TapTapKingfisher.KingfisherCompatible {
}
extension UIKit.NSTextAttachment : TapTapKingfisher.KingfisherCompatible {
}
public enum KingfisherError : Swift.Error {
  public enum RequestErrorReason {
    case emptyRequest
    case invalidURL(request: Foundation.URLRequest)
    case taskCancelled(task: TapTapKingfisher.SessionDataTask, token: TapTapKingfisher.SessionDataTask.CancelToken)
  }
  public enum ResponseErrorReason {
    case invalidURLResponse(response: Foundation.URLResponse)
    case invalidHTTPStatusCode(response: Foundation.HTTPURLResponse)
    case URLSessionError(error: any Swift.Error)
    case dataModifyingFailed(task: TapTapKingfisher.SessionDataTask)
    case noURLResponse(task: TapTapKingfisher.SessionDataTask)
  }
  public enum CacheErrorReason {
    case fileEnumeratorCreationFailed(url: Foundation.URL)
    case invalidFileEnumeratorContent(url: Foundation.URL)
    case invalidURLResource(error: any Swift.Error, key: Swift.String, url: Foundation.URL)
    case cannotLoadDataFromDisk(url: Foundation.URL, error: any Swift.Error)
    case cannotCreateDirectory(path: Swift.String, error: any Swift.Error)
    case imageNotExisting(key: Swift.String)
    case cannotConvertToData(object: Any, error: any Swift.Error)
    case cannotSerializeImage(image: TapTapKingfisher.KFCrossPlatformImage?, original: Foundation.Data?, serializer: any TapTapKingfisher.CacheSerializer)
    case cannotCreateCacheFile(fileURL: Foundation.URL, key: Swift.String, data: Foundation.Data, error: any Swift.Error)
    case cannotSetCacheFileAttribute(filePath: Swift.String, attributes: [Foundation.FileAttributeKey : Any], error: any Swift.Error)
    case diskStorageIsNotReady(cacheURL: Foundation.URL)
  }
  public enum ProcessorErrorReason {
    case processingFailed(processor: any TapTapKingfisher.ImageProcessor, item: TapTapKingfisher.ImageProcessItem)
  }
  public enum ImageSettingErrorReason {
    case emptySource
    case notCurrentSourceTask(result: TapTapKingfisher.RetrieveImageResult?, error: (any Swift.Error)?, source: TapTapKingfisher.Source)
    case dataProviderError(provider: any TapTapKingfisher.ImageDataProvider, error: any Swift.Error)
    case alternativeSourcesExhausted([TapTapKingfisher.PropagationError])
  }
  case requestError(reason: TapTapKingfisher.KingfisherError.RequestErrorReason)
  case responseError(reason: TapTapKingfisher.KingfisherError.ResponseErrorReason)
  case cacheError(reason: TapTapKingfisher.KingfisherError.CacheErrorReason)
  case processorError(reason: TapTapKingfisher.KingfisherError.ProcessorErrorReason)
  case imageSettingError(reason: TapTapKingfisher.KingfisherError.ImageSettingErrorReason)
  public var isTaskCancelled: Swift.Bool {
    get
  }
  public func isInvalidResponseStatusCode(_ code: Swift.Int) -> Swift.Bool
  public var isInvalidResponseStatusCode: Swift.Bool {
    get
  }
  public var isNotCurrentTask: Swift.Bool {
    get
  }
}
extension TapTapKingfisher.KingfisherError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
extension TapTapKingfisher.KingfisherError : Foundation.CustomNSError {
  public static let domain: Swift.String
  public var errorCode: Swift.Int {
    get
  }
}
public typealias DownloadProgressBlock = (_ receivedSize: Swift.Int64, _ totalSize: Swift.Int64) -> Swift.Void
public struct RetrieveImageResult {
  public let image: TapTapKingfisher.KFCrossPlatformImage
  public let cacheType: TapTapKingfisher.CacheType
  public let source: TapTapKingfisher.Source
  public let originalSource: TapTapKingfisher.Source
}
public struct PropagationError {
  public let source: TapTapKingfisher.Source
  public let error: TapTapKingfisher.KingfisherError
}
public typealias DownloadTaskUpdatedBlock = (_ newTask: TapTapKingfisher.DownloadTask?) -> Swift.Void
public class KingfisherManager {
  public static let shared: TapTapKingfisher.KingfisherManager
  public var cache: TapTapKingfisher.ImageCache
  public var downloader: TapTapKingfisher.ImageDownloader
  public var defaultOptions: TapTapKingfisher.KingfisherOptionsInfo
  public init(downloader: TapTapKingfisher.ImageDownloader, cache: TapTapKingfisher.ImageCache)
  @discardableResult
  public func retrieveImage(with resource: any TapTapKingfisher.Resource, options: TapTapKingfisher.KingfisherOptionsInfo? = nil, progressBlock: TapTapKingfisher.DownloadProgressBlock? = nil, downloadTaskUpdated: TapTapKingfisher.DownloadTaskUpdatedBlock? = nil, completionHandler: ((Swift.Result<TapTapKingfisher.RetrieveImageResult, TapTapKingfisher.KingfisherError>) -> Swift.Void)?) -> TapTapKingfisher.DownloadTask?
  public func retrieveImage(with source: TapTapKingfisher.Source, options: TapTapKingfisher.KingfisherOptionsInfo? = nil, progressBlock: TapTapKingfisher.DownloadProgressBlock? = nil, downloadTaskUpdated: TapTapKingfisher.DownloadTaskUpdatedBlock? = nil, completionHandler: ((Swift.Result<TapTapKingfisher.RetrieveImageResult, TapTapKingfisher.KingfisherError>) -> Swift.Void)?) -> TapTapKingfisher.DownloadTask?
  @objc deinit
}
public typealias KingfisherOptionsInfo = [TapTapKingfisher.KingfisherOptionsInfoItem]
public enum KingfisherOptionsInfoItem {
  case targetCache(TapTapKingfisher.ImageCache)
  case originalCache(TapTapKingfisher.ImageCache)
  case downloader(TapTapKingfisher.ImageDownloader)
  case transition(TapTapKingfisher.ImageTransition)
  case downloadPriority(Swift.Float)
  case forceRefresh
  case fromMemoryCacheOrRefresh
  case forceTransition
  case cacheMemoryOnly
  case waitForCache
  case onlyFromCache
  case backgroundDecode
  case callbackQueue(TapTapKingfisher.CallbackQueue)
  case scaleFactor(CoreFoundation.CGFloat)
  case preloadAllAnimationData
  case requestModifier(any TapTapKingfisher.AsyncImageDownloadRequestModifier)
  case redirectHandler(any TapTapKingfisher.ImageDownloadRedirectHandler)
  case processor(any TapTapKingfisher.ImageProcessor)
  case cacheSerializer(any TapTapKingfisher.CacheSerializer)
  case imageModifier(any TapTapKingfisher.ImageModifier)
  case keepCurrentImageWhileLoading
  case onlyLoadFirstFrame
  case cacheOriginalImage
  case onFailureImage(TapTapKingfisher.KFCrossPlatformImage?)
  case alsoPrefetchToMemory
  case loadDiskFileSynchronously
  case memoryCacheExpiration(TapTapKingfisher.StorageExpiration)
  case memoryCacheAccessExtendingExpiration(TapTapKingfisher.ExpirationExtending)
  case diskCacheExpiration(TapTapKingfisher.StorageExpiration)
  case diskCacheAccessExtendingExpiration(TapTapKingfisher.ExpirationExtending)
  case processingQueue(TapTapKingfisher.CallbackQueue)
  case progressiveJPEG(TapTapKingfisher.ImageProgressive)
  case alternativeSources([TapTapKingfisher.Source])
  case retryStrategy(any TapTapKingfisher.RetryStrategy)
  case lowDataMode(TapTapKingfisher.Source?)
}
public struct KingfisherParsedOptionsInfo {
  public var targetCache: TapTapKingfisher.ImageCache?
  public var originalCache: TapTapKingfisher.ImageCache?
  public var downloader: TapTapKingfisher.ImageDownloader?
  public var transition: TapTapKingfisher.ImageTransition
  public var downloadPriority: Swift.Float
  public var forceRefresh: Swift.Bool
  public var fromMemoryCacheOrRefresh: Swift.Bool
  public var forceTransition: Swift.Bool
  public var cacheMemoryOnly: Swift.Bool
  public var waitForCache: Swift.Bool
  public var onlyFromCache: Swift.Bool
  public var backgroundDecode: Swift.Bool
  public var preloadAllAnimationData: Swift.Bool
  public var callbackQueue: TapTapKingfisher.CallbackQueue
  public var scaleFactor: CoreFoundation.CGFloat
  public var requestModifier: (any TapTapKingfisher.AsyncImageDownloadRequestModifier)?
  public var redirectHandler: (any TapTapKingfisher.ImageDownloadRedirectHandler)?
  public var processor: any TapTapKingfisher.ImageProcessor
  public var imageModifier: (any TapTapKingfisher.ImageModifier)?
  public var cacheSerializer: any TapTapKingfisher.CacheSerializer
  public var keepCurrentImageWhileLoading: Swift.Bool
  public var onlyLoadFirstFrame: Swift.Bool
  public var cacheOriginalImage: Swift.Bool
  public var onFailureImage: TapTapKingfisher.KFCrossPlatformImage??
  public var alsoPrefetchToMemory: Swift.Bool
  public var loadDiskFileSynchronously: Swift.Bool
  public var memoryCacheExpiration: TapTapKingfisher.StorageExpiration?
  public var memoryCacheAccessExtendingExpiration: TapTapKingfisher.ExpirationExtending
  public var diskCacheExpiration: TapTapKingfisher.StorageExpiration?
  public var diskCacheAccessExtendingExpiration: TapTapKingfisher.ExpirationExtending
  public var processingQueue: TapTapKingfisher.CallbackQueue?
  public var progressiveJPEG: TapTapKingfisher.ImageProgressive?
  public var alternativeSources: [TapTapKingfisher.Source]?
  public var retryStrategy: (any TapTapKingfisher.RetryStrategy)?
  public var lowDataModeSource: TapTapKingfisher.Source?
  public init(_ info: TapTapKingfisher.KingfisherOptionsInfo?)
}
public typealias Transformer = (CoreImage.CIImage) -> CoreImage.CIImage?
public protocol CIImageProcessor : TapTapKingfisher.ImageProcessor {
  var filter: TapTapKingfisher.Filter { get }
}
extension TapTapKingfisher.CIImageProcessor {
  public func process(item: TapTapKingfisher.ImageProcessItem, options: TapTapKingfisher.KingfisherParsedOptionsInfo) -> TapTapKingfisher.KFCrossPlatformImage?
}
public struct Filter {
  public init(transform: @escaping TapTapKingfisher.Transformer)
  public static var tint: (_ color: TapTapKingfisher.KFCrossPlatformColor) -> TapTapKingfisher.Filter
  public typealias ColorElement = (CoreFoundation.CGFloat, CoreFoundation.CGFloat, CoreFoundation.CGFloat, CoreFoundation.CGFloat)
  public static var colorControl: (_ arg: TapTapKingfisher.Filter.ColorElement) -> TapTapKingfisher.Filter
}
extension TapTapKingfisher.KingfisherWrapper where Base : UIKit.UIImage {
  public func apply(_ filter: TapTapKingfisher.Filter) -> TapTapKingfisher.KFCrossPlatformImage
}
public struct ImageCreatingOptions {
  public let scale: CoreFoundation.CGFloat
  public let duration: Foundation.TimeInterval
  public let preloadAll: Swift.Bool
  public let onlyFirstFrame: Swift.Bool
  public init(scale: CoreFoundation.CGFloat = 1.0, duration: Foundation.TimeInterval = 0.0, preloadAll: Swift.Bool = false, onlyFirstFrame: Swift.Bool = false)
}
extension TapTapKingfisher.KingfisherWrapper where Base : UIKit.UIImage {
  public var imageFrameCount: Swift.Int? {
    get
    set
  }
}
extension TapTapKingfisher.KingfisherWrapper where Base : UIKit.UIImage {
  public var normalized: TapTapKingfisher.KFCrossPlatformImage {
    get
  }
}
extension TapTapKingfisher.KingfisherWrapper where Base : UIKit.UIImage {
  public func pngRepresentation() -> Foundation.Data?
  public func jpegRepresentation(compressionQuality: CoreFoundation.CGFloat) -> Foundation.Data?
  public func gifRepresentation() -> Foundation.Data?
  public func data(format: TapTapKingfisher.ImageFormat, compressionQuality: CoreFoundation.CGFloat = 1.0) -> Foundation.Data?
}
extension TapTapKingfisher.KingfisherWrapper where Base : UIKit.UIImage {
  public static func animatedImage(data: Foundation.Data, options: TapTapKingfisher.ImageCreatingOptions) -> TapTapKingfisher.KFCrossPlatformImage?
  public static func image(data: Foundation.Data, options: TapTapKingfisher.ImageCreatingOptions) -> TapTapKingfisher.KFCrossPlatformImage?
  public static func downsampledImage(data: Foundation.Data, to pointSize: CoreFoundation.CGSize, scale: CoreFoundation.CGFloat) -> TapTapKingfisher.KFCrossPlatformImage?
}
extension TapTapKingfisher.KingfisherWrapper where Base : UIKit.UIImage {
  public func image(withBlendMode blendMode: CoreGraphics.CGBlendMode, alpha: CoreFoundation.CGFloat = 1.0, backgroundColor: TapTapKingfisher.KFCrossPlatformColor? = nil) -> TapTapKingfisher.KFCrossPlatformImage
  public func image(withRoundRadius radius: CoreFoundation.CGFloat, fit size: CoreFoundation.CGSize, roundingCorners corners: TapTapKingfisher.RectCorner = .all, backgroundColor: TapTapKingfisher.KFCrossPlatformColor? = nil) -> TapTapKingfisher.KFCrossPlatformImage
  public func resize(to size: CoreFoundation.CGSize) -> TapTapKingfisher.KFCrossPlatformImage
  public func resize(to targetSize: CoreFoundation.CGSize, for contentMode: TapTapKingfisher.ContentMode) -> TapTapKingfisher.KFCrossPlatformImage
  public func crop(to size: CoreFoundation.CGSize, anchorOn anchor: CoreFoundation.CGPoint) -> TapTapKingfisher.KFCrossPlatformImage
  public func blurred(withRadius radius: CoreFoundation.CGFloat) -> TapTapKingfisher.KFCrossPlatformImage
  public func overlaying(with color: TapTapKingfisher.KFCrossPlatformColor, fraction: CoreFoundation.CGFloat) -> TapTapKingfisher.KFCrossPlatformImage
  public func tinted(with color: TapTapKingfisher.KFCrossPlatformColor) -> TapTapKingfisher.KFCrossPlatformImage
  public func adjusted(brightness: CoreFoundation.CGFloat, contrast: CoreFoundation.CGFloat, saturation: CoreFoundation.CGFloat, inputEV: CoreFoundation.CGFloat) -> TapTapKingfisher.KFCrossPlatformImage
  public func scaled(to scale: CoreFoundation.CGFloat) -> TapTapKingfisher.KFCrossPlatformImage
}
extension TapTapKingfisher.KingfisherWrapper where Base : UIKit.UIImage {
  public var decoded: TapTapKingfisher.KFCrossPlatformImage {
    get
  }
  public func decoded(scale: CoreFoundation.CGFloat) -> TapTapKingfisher.KFCrossPlatformImage
  public func decoded(on context: CoreGraphics.CGContext) -> TapTapKingfisher.KFCrossPlatformImage
}
public enum ImageFormat {
  case unknown
  case PNG
  case JPEG
  case GIF
  public enum JPEGMarker {
    case SOF0
    case SOF2
    case DHT
    case DQT
    case DRI
    case SOS
    case RSTn(Swift.UInt8)
    case APPn
    case COM
    case EOI
  }
  public static func == (a: TapTapKingfisher.ImageFormat, b: TapTapKingfisher.ImageFormat) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.Data : TapTapKingfisher.KingfisherCompatibleValue {
}
extension TapTapKingfisher.KingfisherWrapper where Base == Foundation.Data {
  public var imageFormat: TapTapKingfisher.ImageFormat {
    get
  }
  public func contains(jpeg marker: TapTapKingfisher.ImageFormat.JPEGMarker) -> Swift.Bool
}
public enum ImageProcessItem {
  case image(TapTapKingfisher.KFCrossPlatformImage)
  case data(Foundation.Data)
}
public protocol ImageProcessor {
  var identifier: Swift.String { get }
  func process(item: TapTapKingfisher.ImageProcessItem, options: TapTapKingfisher.KingfisherParsedOptionsInfo) -> TapTapKingfisher.KFCrossPlatformImage?
}
extension TapTapKingfisher.ImageProcessor {
  public func append(another: any TapTapKingfisher.ImageProcessor) -> any TapTapKingfisher.ImageProcessor
}
public struct DefaultImageProcessor : TapTapKingfisher.ImageProcessor {
  public static let `default`: TapTapKingfisher.DefaultImageProcessor
  public let identifier: Swift.String
  public init()
  public func process(item: TapTapKingfisher.ImageProcessItem, options: TapTapKingfisher.KingfisherParsedOptionsInfo) -> TapTapKingfisher.KFCrossPlatformImage?
}
public struct RectCorner : Swift.OptionSet {
  public let rawValue: Swift.Int
  public static let topLeft: TapTapKingfisher.RectCorner
  public static let topRight: TapTapKingfisher.RectCorner
  public static let bottomLeft: TapTapKingfisher.RectCorner
  public static let bottomRight: TapTapKingfisher.RectCorner
  public static let all: TapTapKingfisher.RectCorner
  public init(rawValue: Swift.Int)
  public typealias ArrayLiteralElement = TapTapKingfisher.RectCorner
  public typealias Element = TapTapKingfisher.RectCorner
  public typealias RawValue = Swift.Int
}
public struct BlendImageProcessor : TapTapKingfisher.ImageProcessor {
  public let identifier: Swift.String
  public let blendMode: CoreGraphics.CGBlendMode
  public let alpha: CoreFoundation.CGFloat
  public let backgroundColor: TapTapKingfisher.KFCrossPlatformColor?
  public init(blendMode: CoreGraphics.CGBlendMode, alpha: CoreFoundation.CGFloat = 1.0, backgroundColor: TapTapKingfisher.KFCrossPlatformColor? = nil)
  public func process(item: TapTapKingfisher.ImageProcessItem, options: TapTapKingfisher.KingfisherParsedOptionsInfo) -> TapTapKingfisher.KFCrossPlatformImage?
}
public struct RoundCornerImageProcessor : TapTapKingfisher.ImageProcessor {
  public enum Radius {
    case widthFraction(CoreFoundation.CGFloat)
    case heightFraction(CoreFoundation.CGFloat)
    case point(CoreFoundation.CGFloat)
  }
  public let identifier: Swift.String
  public let radius: TapTapKingfisher.RoundCornerImageProcessor.Radius
  public let roundingCorners: TapTapKingfisher.RectCorner
  public let targetSize: CoreFoundation.CGSize?
  public let backgroundColor: TapTapKingfisher.KFCrossPlatformColor?
  public init(cornerRadius: CoreFoundation.CGFloat, targetSize: CoreFoundation.CGSize? = nil, roundingCorners corners: TapTapKingfisher.RectCorner = .all, backgroundColor: TapTapKingfisher.KFCrossPlatformColor? = nil)
  public init(radius: TapTapKingfisher.RoundCornerImageProcessor.Radius, targetSize: CoreFoundation.CGSize? = nil, roundingCorners corners: TapTapKingfisher.RectCorner = .all, backgroundColor: TapTapKingfisher.KFCrossPlatformColor? = nil)
  public func process(item: TapTapKingfisher.ImageProcessItem, options: TapTapKingfisher.KingfisherParsedOptionsInfo) -> TapTapKingfisher.KFCrossPlatformImage?
}
public enum ContentMode {
  case none
  case aspectFit
  case aspectFill
  public static func == (a: TapTapKingfisher.ContentMode, b: TapTapKingfisher.ContentMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ResizingImageProcessor : TapTapKingfisher.ImageProcessor {
  public let identifier: Swift.String
  public let referenceSize: CoreFoundation.CGSize
  public let targetContentMode: TapTapKingfisher.ContentMode
  public init(referenceSize: CoreFoundation.CGSize, mode: TapTapKingfisher.ContentMode = .none)
  public func process(item: TapTapKingfisher.ImageProcessItem, options: TapTapKingfisher.KingfisherParsedOptionsInfo) -> TapTapKingfisher.KFCrossPlatformImage?
}
public struct BlurImageProcessor : TapTapKingfisher.ImageProcessor {
  public let identifier: Swift.String
  public let blurRadius: CoreFoundation.CGFloat
  public init(blurRadius: CoreFoundation.CGFloat)
  public func process(item: TapTapKingfisher.ImageProcessItem, options: TapTapKingfisher.KingfisherParsedOptionsInfo) -> TapTapKingfisher.KFCrossPlatformImage?
}
public struct OverlayImageProcessor : TapTapKingfisher.ImageProcessor {
  public let identifier: Swift.String
  public let overlay: TapTapKingfisher.KFCrossPlatformColor
  public let fraction: CoreFoundation.CGFloat
  public init(overlay: TapTapKingfisher.KFCrossPlatformColor, fraction: CoreFoundation.CGFloat = 0.5)
  public func process(item: TapTapKingfisher.ImageProcessItem, options: TapTapKingfisher.KingfisherParsedOptionsInfo) -> TapTapKingfisher.KFCrossPlatformImage?
}
public struct TintImageProcessor : TapTapKingfisher.ImageProcessor {
  public let identifier: Swift.String
  public let tint: TapTapKingfisher.KFCrossPlatformColor
  public init(tint: TapTapKingfisher.KFCrossPlatformColor)
  public func process(item: TapTapKingfisher.ImageProcessItem, options: TapTapKingfisher.KingfisherParsedOptionsInfo) -> TapTapKingfisher.KFCrossPlatformImage?
}
public struct ColorControlsProcessor : TapTapKingfisher.ImageProcessor {
  public let identifier: Swift.String
  public let brightness: CoreFoundation.CGFloat
  public let contrast: CoreFoundation.CGFloat
  public let saturation: CoreFoundation.CGFloat
  public let inputEV: CoreFoundation.CGFloat
  public init(brightness: CoreFoundation.CGFloat, contrast: CoreFoundation.CGFloat, saturation: CoreFoundation.CGFloat, inputEV: CoreFoundation.CGFloat)
  public func process(item: TapTapKingfisher.ImageProcessItem, options: TapTapKingfisher.KingfisherParsedOptionsInfo) -> TapTapKingfisher.KFCrossPlatformImage?
}
public struct BlackWhiteProcessor : TapTapKingfisher.ImageProcessor {
  public let identifier: Swift.String
  public init()
  public func process(item: TapTapKingfisher.ImageProcessItem, options: TapTapKingfisher.KingfisherParsedOptionsInfo) -> TapTapKingfisher.KFCrossPlatformImage?
}
public struct CroppingImageProcessor : TapTapKingfisher.ImageProcessor {
  public let identifier: Swift.String
  public let size: CoreFoundation.CGSize
  public let anchor: CoreFoundation.CGPoint
  public init(size: CoreFoundation.CGSize, anchor: CoreFoundation.CGPoint = CGPoint(x: 0.5, y: 0.5))
  public func process(item: TapTapKingfisher.ImageProcessItem, options: TapTapKingfisher.KingfisherParsedOptionsInfo) -> TapTapKingfisher.KFCrossPlatformImage?
}
public struct DownsamplingImageProcessor : TapTapKingfisher.ImageProcessor {
  public let size: CoreFoundation.CGSize
  public let identifier: Swift.String
  public init(size: CoreFoundation.CGSize)
  public func process(item: TapTapKingfisher.ImageProcessItem, options: TapTapKingfisher.KingfisherParsedOptionsInfo) -> TapTapKingfisher.KFCrossPlatformImage?
}
infix operator |> : AdditionPrecedence
public func |> (left: any TapTapKingfisher.ImageProcessor, right: any TapTapKingfisher.ImageProcessor) -> any TapTapKingfisher.ImageProcessor
public struct ImageProgressive {
  public static let `default`: TapTapKingfisher.ImageProgressive
  public init(isBlur: Swift.Bool, isFastestScan: Swift.Bool, scanInterval: Foundation.TimeInterval)
}
public enum ImageTransition {
  case none
  case fade(Foundation.TimeInterval)
  case flipFromLeft(Foundation.TimeInterval)
  case flipFromRight(Foundation.TimeInterval)
  case flipFromTop(Foundation.TimeInterval)
  case flipFromBottom(Foundation.TimeInterval)
  case custom(duration: Foundation.TimeInterval, options: UIKit.UIView.AnimationOptions, animations: ((UIKit.UIImageView, UIKit.UIImage) -> Swift.Void)?, completion: ((Swift.Bool) -> Swift.Void)?)
}
public protocol Placeholder {
  func add(to imageView: TapTapKingfisher.KFCrossPlatformImageView)
  func remove(from imageView: TapTapKingfisher.KFCrossPlatformImageView)
}
extension UIKit.UIImage : TapTapKingfisher.Placeholder {
  public func add(to imageView: TapTapKingfisher.KFCrossPlatformImageView)
  public func remove(from imageView: TapTapKingfisher.KFCrossPlatformImageView)
}
extension TapTapKingfisher.Placeholder where Self : UIKit.UIView {
  public func add(to imageView: TapTapKingfisher.KFCrossPlatformImageView)
  public func remove(from imageView: TapTapKingfisher.KFCrossPlatformImageView)
}
public protocol AuthenticationChallengeResponsable : AnyObject {
  func downloader(_ downloader: TapTapKingfisher.ImageDownloader, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  func downloader(_ downloader: TapTapKingfisher.ImageDownloader, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
}
extension TapTapKingfisher.AuthenticationChallengeResponsable {
  public func downloader(_ downloader: TapTapKingfisher.ImageDownloader, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  public func downloader(_ downloader: TapTapKingfisher.ImageDownloader, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
}
public struct ImageLoadingResult {
  public let image: TapTapKingfisher.KFCrossPlatformImage
  public let url: Foundation.URL?
  public let originalData: Foundation.Data
}
public struct DownloadTask {
  public let sessionTask: TapTapKingfisher.SessionDataTask
  public let cancelToken: TapTapKingfisher.SessionDataTask.CancelToken
  public func cancel()
}
open class ImageDownloader {
  public static let `default`: TapTapKingfisher.ImageDownloader
  open var downloadTimeout: Swift.Double
  open var trustedHosts: Swift.Set<Swift.String>?
  open var sessionConfiguration: Foundation.URLSessionConfiguration {
    get
    set
  }
  open var sessionDelegate: TapTapKingfisher.SessionDelegate {
    get
    set
  }
  open var requestsUsePipelining: Swift.Bool
  weak open var delegate: (any TapTapKingfisher.ImageDownloaderDelegate)?
  weak open var authenticationChallengeResponder: (any TapTapKingfisher.AuthenticationChallengeResponsable)?
  public init(name: Swift.String)
  @objc deinit
  @discardableResult
  open func downloadImage(with url: Foundation.URL, options: TapTapKingfisher.KingfisherParsedOptionsInfo, completionHandler: ((Swift.Result<TapTapKingfisher.ImageLoadingResult, TapTapKingfisher.KingfisherError>) -> Swift.Void)? = nil) -> TapTapKingfisher.DownloadTask?
  @discardableResult
  open func downloadImage(with url: Foundation.URL, options: TapTapKingfisher.KingfisherOptionsInfo? = nil, progressBlock: TapTapKingfisher.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<TapTapKingfisher.ImageLoadingResult, TapTapKingfisher.KingfisherError>) -> Swift.Void)? = nil) -> TapTapKingfisher.DownloadTask?
  @discardableResult
  open func downloadImage(with url: Foundation.URL, options: TapTapKingfisher.KingfisherOptionsInfo? = nil, completionHandler: ((Swift.Result<TapTapKingfisher.ImageLoadingResult, TapTapKingfisher.KingfisherError>) -> Swift.Void)? = nil) -> TapTapKingfisher.DownloadTask?
}
extension TapTapKingfisher.ImageDownloader {
  public func cancelAll()
  public func cancel(url: Foundation.URL)
}
extension TapTapKingfisher.ImageDownloader : TapTapKingfisher.AuthenticationChallengeResponsable {
}
extension TapTapKingfisher.ImageDownloader : TapTapKingfisher.ImageDownloaderDelegate {
}
public protocol ImageDownloaderDelegate : AnyObject {
  func imageDownloader(_ downloader: TapTapKingfisher.ImageDownloader, willDownloadImageForURL url: Foundation.URL, with request: Foundation.URLRequest?)
  func imageDownloader(_ downloader: TapTapKingfisher.ImageDownloader, didFinishDownloadingImageForURL url: Foundation.URL, with response: Foundation.URLResponse?, error: (any Swift.Error)?)
  func imageDownloader(_ downloader: TapTapKingfisher.ImageDownloader, didDownload data: Foundation.Data, with dataTask: TapTapKingfisher.SessionDataTask) -> Foundation.Data?
  func imageDownloader(_ downloader: TapTapKingfisher.ImageDownloader, didDownload data: Foundation.Data, for url: Foundation.URL) -> Foundation.Data?
  func imageDownloader(_ downloader: TapTapKingfisher.ImageDownloader, didDownload image: TapTapKingfisher.KFCrossPlatformImage, for url: Foundation.URL, with response: Foundation.URLResponse?)
  func isValidStatusCode(_ code: Swift.Int, for downloader: TapTapKingfisher.ImageDownloader) -> Swift.Bool
}
extension TapTapKingfisher.ImageDownloaderDelegate {
  public func imageDownloader(_ downloader: TapTapKingfisher.ImageDownloader, willDownloadImageForURL url: Foundation.URL, with request: Foundation.URLRequest?)
  public func imageDownloader(_ downloader: TapTapKingfisher.ImageDownloader, didFinishDownloadingImageForURL url: Foundation.URL, with response: Foundation.URLResponse?, error: (any Swift.Error)?)
  public func imageDownloader(_ downloader: TapTapKingfisher.ImageDownloader, didDownload image: TapTapKingfisher.KFCrossPlatformImage, for url: Foundation.URL, with response: Foundation.URLResponse?)
  public func isValidStatusCode(_ code: Swift.Int, for downloader: TapTapKingfisher.ImageDownloader) -> Swift.Bool
  public func imageDownloader(_ downloader: TapTapKingfisher.ImageDownloader, didDownload data: Foundation.Data, with task: TapTapKingfisher.SessionDataTask) -> Foundation.Data?
  public func imageDownloader(_ downloader: TapTapKingfisher.ImageDownloader, didDownload data: Foundation.Data, for url: Foundation.URL) -> Foundation.Data?
}
public protocol ImageModifier {
  func modify(_ image: TapTapKingfisher.KFCrossPlatformImage) -> TapTapKingfisher.KFCrossPlatformImage
}
public struct AnyImageModifier : TapTapKingfisher.ImageModifier {
  public init(modify: @escaping (TapTapKingfisher.KFCrossPlatformImage) throws -> TapTapKingfisher.KFCrossPlatformImage)
  public func modify(_ image: TapTapKingfisher.KFCrossPlatformImage) -> TapTapKingfisher.KFCrossPlatformImage
}
public struct RenderingModeImageModifier : TapTapKingfisher.ImageModifier {
  public let renderingMode: UIKit.UIImage.RenderingMode
  public init(renderingMode: UIKit.UIImage.RenderingMode = .automatic)
  public func modify(_ image: TapTapKingfisher.KFCrossPlatformImage) -> TapTapKingfisher.KFCrossPlatformImage
}
public struct FlipsForRightToLeftLayoutDirectionImageModifier : TapTapKingfisher.ImageModifier {
  public init()
  public func modify(_ image: TapTapKingfisher.KFCrossPlatformImage) -> TapTapKingfisher.KFCrossPlatformImage
}
public struct AlignmentRectInsetsImageModifier : TapTapKingfisher.ImageModifier {
  public let alignmentInsets: UIKit.UIEdgeInsets
  public init(alignmentInsets: UIKit.UIEdgeInsets)
  public func modify(_ image: TapTapKingfisher.KFCrossPlatformImage) -> TapTapKingfisher.KFCrossPlatformImage
}
public typealias PrefetcherProgressBlock = (_ skippedResources: [any TapTapKingfisher.Resource], _ failedResources: [any TapTapKingfisher.Resource], _ completedResources: [any TapTapKingfisher.Resource]) -> Swift.Void
public typealias PrefetcherSourceProgressBlock = (_ skippedSources: [TapTapKingfisher.Source], _ failedSources: [TapTapKingfisher.Source], _ completedSources: [TapTapKingfisher.Source]) -> Swift.Void
public typealias PrefetcherCompletionHandler = (_ skippedResources: [any TapTapKingfisher.Resource], _ failedResources: [any TapTapKingfisher.Resource], _ completedResources: [any TapTapKingfisher.Resource]) -> Swift.Void
public typealias PrefetcherSourceCompletionHandler = (_ skippedSources: [TapTapKingfisher.Source], _ failedSources: [TapTapKingfisher.Source], _ completedSources: [TapTapKingfisher.Source]) -> Swift.Void
@_hasMissingDesignatedInitializers public class ImagePrefetcher : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
  public var maxConcurrentDownloads: Swift.Int
  convenience public init(urls: [Foundation.URL], options: TapTapKingfisher.KingfisherOptionsInfo? = nil, progressBlock: TapTapKingfisher.PrefetcherProgressBlock? = nil, completionHandler: TapTapKingfisher.PrefetcherCompletionHandler? = nil)
  convenience public init(urls: [Foundation.URL], options: TapTapKingfisher.KingfisherOptionsInfo? = nil, completionHandler: TapTapKingfisher.PrefetcherCompletionHandler? = nil)
  convenience public init(resources: [any TapTapKingfisher.Resource], options: TapTapKingfisher.KingfisherOptionsInfo? = nil, progressBlock: TapTapKingfisher.PrefetcherProgressBlock? = nil, completionHandler: TapTapKingfisher.PrefetcherCompletionHandler? = nil)
  convenience public init(resources: [any TapTapKingfisher.Resource], options: TapTapKingfisher.KingfisherOptionsInfo? = nil, completionHandler: TapTapKingfisher.PrefetcherCompletionHandler? = nil)
  convenience public init(sources: [TapTapKingfisher.Source], options: TapTapKingfisher.KingfisherOptionsInfo? = nil, progressBlock: TapTapKingfisher.PrefetcherSourceProgressBlock? = nil, completionHandler: TapTapKingfisher.PrefetcherSourceCompletionHandler? = nil)
  convenience public init(sources: [TapTapKingfisher.Source], options: TapTapKingfisher.KingfisherOptionsInfo? = nil, completionHandler: TapTapKingfisher.PrefetcherSourceCompletionHandler? = nil)
  public func start()
  public func stop()
  @objc deinit
}
public protocol ImageDownloadRedirectHandler {
  func handleHTTPRedirection(for task: TapTapKingfisher.SessionDataTask, response: Foundation.HTTPURLResponse, newRequest: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
}
public struct AnyRedirectHandler : TapTapKingfisher.ImageDownloadRedirectHandler {
  public func handleHTTPRedirection(for task: TapTapKingfisher.SessionDataTask, response: Foundation.HTTPURLResponse, newRequest: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
  public init(handle: @escaping (TapTapKingfisher.SessionDataTask, Foundation.HTTPURLResponse, Foundation.URLRequest, @escaping (Foundation.URLRequest?) -> Swift.Void) -> Swift.Void)
}
public protocol AsyncImageDownloadRequestModifier {
  func modified(for request: Foundation.URLRequest, reportModified: @escaping (Foundation.URLRequest?) -> Swift.Void)
  var onDownloadTaskStarted: ((TapTapKingfisher.DownloadTask?) -> Swift.Void)? { get }
}
public protocol ImageDownloadRequestModifier : TapTapKingfisher.AsyncImageDownloadRequestModifier {
  func modified(for request: Foundation.URLRequest) -> Foundation.URLRequest?
}
extension TapTapKingfisher.ImageDownloadRequestModifier {
  public func modified(for request: Foundation.URLRequest, reportModified: @escaping (Foundation.URLRequest?) -> Swift.Void)
  public var onDownloadTaskStarted: ((TapTapKingfisher.DownloadTask?) -> Swift.Void)? {
    get
  }
}
public struct AnyModifier : TapTapKingfisher.ImageDownloadRequestModifier {
  public func modified(for request: Foundation.URLRequest) -> Foundation.URLRequest?
  public init(modify: @escaping (Foundation.URLRequest) -> Foundation.URLRequest?)
}
@_hasMissingDesignatedInitializers public class RetryContext {
  final public let source: TapTapKingfisher.Source
  final public let error: TapTapKingfisher.KingfisherError
  public var retriedCount: Swift.Int
  public var userInfo: Any? {
    get
  }
  @objc deinit
}
public enum RetryDecision {
  case retry(userInfo: Any?)
  case stop
}
public protocol RetryStrategy {
  func retry(context: TapTapKingfisher.RetryContext, retryHandler: @escaping (TapTapKingfisher.RetryDecision) -> Swift.Void)
}
public struct DelayRetryStrategy : TapTapKingfisher.RetryStrategy {
  public enum Interval {
    case seconds(Foundation.TimeInterval)
    case accumulated(Foundation.TimeInterval)
    case custom(block: (_ retriedCount: Swift.Int) -> Foundation.TimeInterval)
  }
  public let maxRetryCount: Swift.Int
  public let retryInterval: TapTapKingfisher.DelayRetryStrategy.Interval
  public init(maxRetryCount: Swift.Int, retryInterval: TapTapKingfisher.DelayRetryStrategy.Interval = .seconds(3))
  public func retry(context: TapTapKingfisher.RetryContext, retryHandler: @escaping (TapTapKingfisher.RetryDecision) -> Swift.Void)
}
@_hasMissingDesignatedInitializers public class SessionDataTask {
  public typealias CancelToken = Swift.Int
  public var mutableData: Foundation.Data {
    get
  }
  final public let originalURL: Foundation.URL?
  final public let task: Foundation.URLSessionDataTask
  @objc deinit
}
@_inheritsConvenienceInitializers @objc(KFSessionDelegate) open class SessionDelegate : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
extension TapTapKingfisher.SessionDelegate : Foundation.URLSessionDataDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive response: Foundation.URLResponse, completionHandler: @escaping (Foundation.URLSession.ResponseDisposition) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
}
public enum CallbackQueue {
  case mainAsync
  case mainCurrentOrAsync
  case untouch
  case dispatch(Dispatch.DispatchQueue)
  public func execute(_ block: @escaping () -> Swift.Void)
}
public class Delegate<Input, Output> {
  public init()
  public func delegate<T>(on target: T, block: ((T, Input) -> Output)?) where T : AnyObject
  public func call(_ input: Input) -> Output?
  public func callAsFunction(_ input: Input) -> Output?
  @objc deinit
}
extension TapTapKingfisher.Delegate where Input == () {
  public func call() -> Output?
  public func callAsFunction() -> Output?
}
extension TapTapKingfisher.Delegate where Input == (), Output : TapTapKingfisher.OptionalProtocol {
  public func call() -> Output
  public func callAsFunction() -> Output
}
extension TapTapKingfisher.Delegate where Output : TapTapKingfisher.OptionalProtocol {
  public func call(_ input: Input) -> Output
  public func callAsFunction(_ input: Input) -> Output
}
public protocol OptionalProtocol {
  static var _createNil: Self { get }
}
extension Swift.Optional : TapTapKingfisher.OptionalProtocol {
  public static var _createNil: Swift.Optional<Wrapped> {
    get
  }
}
extension CoreFoundation.CGSize : TapTapKingfisher.KingfisherCompatibleValue {
}
extension TapTapKingfisher.KingfisherWrapper where Base == CoreFoundation.CGSize {
  public func resize(to size: CoreFoundation.CGSize, for contentMode: TapTapKingfisher.ContentMode) -> CoreFoundation.CGSize
  public func constrained(_ size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  public func filling(_ size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  public func constrainedRect(for size: CoreFoundation.CGSize, anchor: CoreFoundation.CGPoint) -> CoreFoundation.CGRect
}
public protocol AnimatedImageViewDelegate : AnyObject {
  func animatedImageView(_ imageView: TapTapKingfisher.AnimatedImageView, didPlayAnimationLoops count: Swift.UInt)
  func animatedImageViewDidFinishAnimating(_ imageView: TapTapKingfisher.AnimatedImageView)
}
extension TapTapKingfisher.AnimatedImageViewDelegate {
  public func animatedImageView(_ imageView: TapTapKingfisher.AnimatedImageView, didPlayAnimationLoops count: Swift.UInt)
  public func animatedImageViewDidFinishAnimating(_ imageView: TapTapKingfisher.AnimatedImageView)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class AnimatedImageView : UIKit.UIImageView {
  public enum RepeatCount : Swift.Equatable {
    case once
    case finite(count: Swift.UInt)
    case infinite
    public static func == (lhs: TapTapKingfisher.AnimatedImageView.RepeatCount, rhs: TapTapKingfisher.AnimatedImageView.RepeatCount) -> Swift.Bool
  }
  @_Concurrency.MainActor @preconcurrency public var autoPlayAnimatedImage: Swift.Bool
  @_Concurrency.MainActor @preconcurrency public var framePreloadCount: Swift.Int
  @_Concurrency.MainActor @preconcurrency public var needsPrescaling: Swift.Bool
  @_Concurrency.MainActor @preconcurrency public var backgroundDecode: Swift.Bool
  @_Concurrency.MainActor @preconcurrency public var runLoopMode: Foundation.RunLoop.Mode {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var repeatCount: TapTapKingfisher.AnimatedImageView.RepeatCount {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency weak public var delegate: (any TapTapKingfisher.AnimatedImageViewDelegate)?
  @_Concurrency.MainActor @preconcurrency public var animator: TapTapKingfisher.AnimatedImageView.Animator? {
    get
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var image: TapTapKingfisher.KFCrossPlatformImage? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var isHighlighted: Swift.Bool {
    @objc get
    @objc set
  }
  @objc deinit
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var isAnimating: Swift.Bool {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func startAnimating()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func stopAnimating()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func display(_ layer: QuartzCore.CALayer)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func didMoveToWindow()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func didMoveToSuperview()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(image: UIKit.UIImage?)
  @available(iOS 3.0, *)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(image: UIKit.UIImage?, highlightedImage: UIKit.UIImage?)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
}
extension TapTapKingfisher.AnimatedImageView {
  @_hasMissingDesignatedInitializers public class Animator {
    final public let maxFrameCount: Swift.Int
    public var currentFrameImage: UIKit.UIImage? {
      get
    }
    public var currentFrameDuration: Foundation.TimeInterval {
      get
    }
    public var currentFrameIndex: Swift.Int {
      get
    }
    public var isLastFrame: Swift.Bool {
      get
    }
    @objc deinit
    public func frame(at index: Swift.Int) -> TapTapKingfisher.KFCrossPlatformImage?
    public func duration(at index: Swift.Int) -> Foundation.TimeInterval
  }
}
public typealias IndicatorView = UIKit.UIView
public enum IndicatorType {
  case none
  case activity
  case image(imageData: Foundation.Data)
  case custom(indicator: any TapTapKingfisher.Indicator)
}
public protocol Indicator {
  func startAnimatingView()
  func stopAnimatingView()
  var centerOffset: CoreFoundation.CGPoint { get }
  var view: TapTapKingfisher.IndicatorView { get }
  func sizeStrategy(in imageView: TapTapKingfisher.KFCrossPlatformImageView) -> TapTapKingfisher.IndicatorSizeStrategy
}
public enum IndicatorSizeStrategy {
  case intrinsicSize
  case full
  case size(CoreFoundation.CGSize)
}
extension TapTapKingfisher.Indicator {
  public var centerOffset: CoreFoundation.CGPoint {
    get
  }
  public func sizeStrategy(in imageView: TapTapKingfisher.KFCrossPlatformImageView) -> TapTapKingfisher.IndicatorSizeStrategy
}
extension TapTapKingfisher.CacheType : Swift.Equatable {}
extension TapTapKingfisher.CacheType : Swift.Hashable {}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension TapTapKingfisher.KFImage : Swift.Sendable {}
extension TapTapKingfisher.ImageFormat : Swift.Equatable {}
extension TapTapKingfisher.ImageFormat : Swift.Hashable {}
extension TapTapKingfisher.ContentMode : Swift.Equatable {}
extension TapTapKingfisher.ContentMode : Swift.Hashable {}
